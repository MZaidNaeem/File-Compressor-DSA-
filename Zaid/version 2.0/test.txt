#include<iostream>
#include<unordered_map>
#include<fstream>
#include<bitset>
#include<cstdint>
using namespace std;

class HuffmanNode {
public:
    char ch;
    int freq;
    HuffmanNode* left;
    HuffmanNode* right;

    HuffmanNode(char c, int f) : ch(c), freq(f), left(nullptr), right(nullptr) {}
};

class MinHeapTree {
public:
    HuffmanNode* heap[1000];
    int size = 0;

    void insert(HuffmanNode* currentNode) {
        heap[size] = currentNode;
        heapifyUp(size);
        size++;
    }

    HuffmanNode* extractMin() {
        if (size == 0) return nullptr;
        HuffmanNode* root = heap[0];
        heap[0] = heap[--size];
        heapifyDown(0);
        return root;
    }

    void swap(int i, int j) {
        HuffmanNode* temp = heap[i];
        heap[i] = heap[j];
        heap[j] = temp;
    }

    void heapifyDown(int i) {
        int smallest = i, left = 2*i+1, right = 2*i+2;
        if (left < size && heap[left]->freq < heap[smallest]->freq) smallest = left;
        if (right < size && heap[right]->freq < heap[smallest]->freq) smallest = right;
        if (smallest != i) { swap(i, smallest); heapifyDown(smallest); }
    }

    void heapifyUp(int i) {
        int parent = (i-1)/2;
        if (i && heap[i]->freq < heap[parent]->freq) { swap(i, parent); heapifyUp(parent); }
    }

    int getSize() { return size; }
};

void buildCodes(HuffmanNode* root, unordered_map<char, string>& huffmanCodes, string code = "") {
    if (!root) return;
    if (!root->left && !root->right) {
        huffmanCodes[root->ch] = code;
        return;
    }
    buildCodes(root->left, huffmanCodes, code + "0");
    buildCodes(root->right, huffmanCodes, code + "1");
}

string encode(string data, unordered_map<char, string>& huffmanCodes) {
    string output;
    for (char c : data) output += huffmanCodes[c];
    return output;
}

string decode(HuffmanNode* root, string encoded) {
    string decoded;
    HuffmanNode* current = root;
    for (char bit : encoded) {
        current = (bit == '0') ? current->left : current->right;
        if (!current->left && !current->right) {
            decoded += current->ch;
            current = root;
        }
    }
    return decoded;
}

string std_file_read(string fileName) {
    ifstream inFile(fileName);
    if (!inFile) return "";
    string text, line;
    while (getline(inFile, line)) text += line + "\n";
    inFile.close();
    return text;
}

void std_binary_file_write(string encoded, unordered_map<char,int> freq, string fileName) {
    ofstream outFile(fileName + "--Compressed", ios::binary);
    if (!outFile) return;
    int uniqueChars = freq.size();
    outFile.write(reinterpret_cast<const char*>(&uniqueChars), sizeof(uniqueChars));
    for (auto& pair : freq) {
        outFile.put(pair.first);
        int f = pair.second;
        outFile.write(reinterpret_cast<const char*>(&f), sizeof(f));
    }
    int validBitsInLastByte = encoded.size() % 8;
    if (validBitsInLastByte == 0) validBitsInLastByte = 8;
    outFile.put(static_cast<char>(validBitsInLastByte));
    char byte = 0;
    int bitCount = 0;
    for (char bit : encoded) {
        byte = (byte << 1) | (bit == '1');
        if (++bitCount == 8) {
            outFile.put(byte);
            byte = 0;
            bitCount = 0;
        }
    }
    if (bitCount > 0) {
        byte <<= (8 - bitCount);
        outFile.put(byte);
    }
    outFile.close();
}

unordered_map<char, int> readFrequencyTable(ifstream& inFile) {
    unordered_map<char, int> freq;
    int uniqueChars;
    inFile.read(reinterpret_cast<char*>(&uniqueChars), sizeof(uniqueChars));
    for (int i = 0; i < uniqueChars; i++) {
        char ch;
        int f;
        inFile.read(reinterpret_cast<char*>(&ch), sizeof(ch));
        inFile.read(reinterpret_cast<char*>(&f), sizeof(f));
        freq[ch] = f;
    }
    return freq;
}

string std_binary_file_read_with_freq(string fileName, unordered_map<char,int>& freq) {
    ifstream inFile(fileName, ios::binary);
    if (!inFile) return "";
    freq = readFrequencyTable(inFile);
    char validBitsChar;
    inFile.get(validBitsChar);
    int validBitsInLastByte = static_cast<unsigned char>(validBitsChar);
    string bits;
    char byte;
    while (inFile.get(byte)) bits += bitset<8>(static_cast<unsigned char>(byte)).to_string();
    inFile.close();
    if (!bits.empty() && validBitsInLastByte < 8)
        bits = bits.substr(0, bits.size() - 8 + validBitsInLastByte);
    return bits;
}

int main() {
    int choice;
    string fileName;
    do {
        cout << "\n=== HUFFMAN COMPRESSION ===\n1. Compress a file\n2. Decompress a file\n0. Exit\nChoice: ";
        cin >> choice;
        switch (choice) {
            case 1: {
                unordered_map<char, string> huffmanCodes;
                cout << "\nEnter file name (without .txt): ";
                cin >> fileName;
                string text = std_file_read(fileName + ".txt");
                unordered_map<char, int> freq;
                for (char c : text) freq[c]++;
                MinHeapTree heap;
                for (auto& p : freq) heap.insert(new HuffmanNode(p.first, p.second));
                while (heap.getSize() > 1) {
                    HuffmanNode *l = heap.extractMin(), *r = heap.extractMin();
                    HuffmanNode* merged = new HuffmanNode('\0', l->freq + r->freq);
                    merged->left = l; merged->right = r;
                    heap.insert(merged);
                }
                HuffmanNode* root = heap.extractMin();
                buildCodes(root, huffmanCodes);
                string encoded = encode(text, huffmanCodes);
                string decoded = decode(root, encoded);
                int originalSize = text.size();
                int compressedSize = 4 + freq.size() * 5 + 1 + encoded.size() / 8;
                cout << "\nOriginal Size     : " << originalSize << " Bytes";
                cout << "\nCompressed Size   : " << compressedSize << " Bytes\n";
                std_binary_file_write(encoded, freq, fileName);
                break;
            }
            case 2: {
                cout << "\nEnter compressed file name (e.g., file--Compressed): ";
                cin >> fileName;
                unordered_map<char, int> freq;
                string encodedBits = std_binary_file_read_with_freq(fileName, freq);
                MinHeapTree heap;
                for (auto& p : freq) heap.insert(new HuffmanNode(p.first, p.second));
                while (heap.getSize() > 1) {
                    HuffmanNode *l = heap.extractMin(), *r = heap.extractMin();
                    HuffmanNode* merged = new HuffmanNode('\0', l->freq + r->freq);
                    merged->left = l; merged->right = r;
                    heap.insert(merged);
                }
                HuffmanNode* root = heap.extractMin();
                string decoded = decode(root, encodedBits);
                cout << "\nDecoded Text:\n" << decoded << endl;
                break;
            }
            case 0:
                cout << "\nExiting...\n";
                break;
            default:
                cout << "\nInvalid choice. Try again.\n";
        }
    } while (choice != 0);
    return 0;
}
